<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="3W1ar6zfFsnaL1sEvDzeytVUVg5oGeuj2l0iM0svaJw">













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  

  

  

  

  

  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="FE, 前端, Javascript, Nodejs, blog, 前端博客, React, Vue ">





  <link rel="alternate" href="/atom.xml" title="Kevin's Notes" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="#目录ECMAScript 6.0已经在2015年6月17日正式发布（以下简称ES6）到现在已经过去了2年时间，发布的很多新的特征已成为了标准，如今ES8草案也公布了，Javascript的未来还是值得期待的；我从去年下半年开始接触ES6的，在代码上搭配babel来开发基于React框架的应用，发现其中许多特性确实简化了很多代码的编写，之前一直没有系统性得去学习这些新的特征，这篇博客">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6(ECMAScript 6.0)新特征">
<meta property="og:url" content="https://wuxinhua.com/2017/08/28/The-es6-features-learning-notes/index.html">
<meta property="og:site_name" content="Kevin&#39;s Notes">
<meta property="og:description" content="#目录ECMAScript 6.0已经在2015年6月17日正式发布（以下简称ES6）到现在已经过去了2年时间，发布的很多新的特征已成为了标准，如今ES8草案也公布了，Javascript的未来还是值得期待的；我从去年下半年开始接触ES6的，在代码上搭配babel来开发基于React框架的应用，发现其中许多特性确实简化了很多代码的编写，之前一直没有系统性得去学习这些新的特征，这篇博客">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://assets.wuxinhua.com//blog/assets/es6/es2015.png">
<meta property="og:updated_time" content="2020-12-31T12:01:49.411Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6(ECMAScript 6.0)新特征">
<meta name="twitter:description" content="#目录ECMAScript 6.0已经在2015年6月17日正式发布（以下简称ES6）到现在已经过去了2年时间，发布的很多新的特征已成为了标准，如今ES8草案也公布了，Javascript的未来还是值得期待的；我从去年下半年开始接触ES6的，在代码上搭配babel来开发基于React框架的应用，发现其中许多特性确实简化了很多代码的编写，之前一直没有系统性得去学习这些新的特征，这篇博客">
<meta name="twitter:image" content="https://assets.wuxinhua.com//blog/assets/es6/es2015.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wuxinhua.com/2017/08/28/The-es6-features-learning-notes/">





  <title>ES6(ECMAScript 6.0)新特征 | Kevin's Notes</title>
  













</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146717212-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-146717212-1');
</script>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button role="presentation">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archive
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://wuxinhua.com/2017/08/28/The-es6-features-learning-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuxinhua">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">ES6(ECMAScript 6.0)新特征</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-28T17:54:57+08:00">
                2017-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- ![title](https://assets.wuxinhua.com/es6.jpeg) -->
<p><img src="https://assets.wuxinhua.com//blog/assets/es6/es2015.png" alt></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h3><p>ECMAScript 6.0已经在2015年6月17日正式发布（以下简称ES6）到现在已经过去了2年时间，发布的很多新的特征已成为了标准，如今ES8草案也公布了，Javascript的未来还是值得期待的；我从去年下半年开始接触ES6的，在代码上搭配babel来开发基于React框架的应用，发现其中许多特性确实简化了很多代码的编写，之前一直没有系统性得去学习这些新的特征，这篇博客算是我的ES6学习笔记，从简单的数组的一些新方法开始，ES6模块系统、class类…到较复杂的generator函数结束。完成之后，我会再陆续记录ES7、ES8..学习笔记。本篇包含以下内容：</p>
<ul>
<li>数组方法扩展</li>
<li>解构赋值</li>
<li>let和const</li>
<li>箭头函数</li>
<li>字符串模板</li>
<li>Promise</li>
<li>Set和Map</li>
<li>字符串扩展  </li>
<li>Symbol</li>
<li>模块Module</li>
<li>Class</li>
<li>Proxy</li>
<li>Generator</li>
</ul>
<h3 id="数组方法扩展"><a href="#数组方法扩展" class="headerlink" title="#数组方法扩展"></a>#数组方法扩展</h3><h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h4><p>新增includes方法，类似于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" rel="noopener">String.prototype.includes</a>，在这之前我们一般是使用下面这样的代码来判断数组中是否存在某个元素,<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用indexOf有两个问题：</p>
<ul>
<li>违背“所见即所得”原则，indexOf方法它是用来返回下标位置的，并不能直观表达是否存在包含关系。</li>
<li>无法判断NaN,[NaN].indexOf(NaN) &gt; 0 // false</li>
</ul>
<p>注意：includes只接受两个参数，接收2参数，查询的项以及查询起始位置<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include 返回boolean值</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].includes(<span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);  <span class="comment">// true</span></span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].includes(<span class="string">'a'</span>, <span class="string">'b'</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].includes(<span class="string">'a'</span>, <span class="string">'d'</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].includes(<span class="string">'a'</span>, <span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Array-prototype-from"><a href="#Array-prototype-from" class="headerlink" title="Array.prototype.from"></a>Array.prototype.from</h4><p>from 方法用于将类似数组的对象（key-value结构）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转换成数组。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">'hello'</span>)); <span class="comment">// [ 'h', 'e', 'l', 'l', 'o' ]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objLike = &#123; <span class="number">0</span>: <span class="number">0</span>,  <span class="number">1</span>: <span class="number">1</span>,  <span class="number">2</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(objLike)); <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>from还接受第二个方法类型的参数，类似map方法返回经方法处理过的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objLike = &#123; <span class="number">0</span>: <span class="number">0</span>,  <span class="number">1</span>: <span class="number">1</span>,  <span class="number">2</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(objLike, (k) =&gt; k+=<span class="number">1</span>;))); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-prototype-of"><a href="#Array-prototype-of" class="headerlink" title="Array.prototype.of"></a>Array.prototype.of</h4><p>of方法比from更简单，将一组值转换成数组,为了弥补使用new Array()构造数组的奇怪行为。<br>先看下new Array为我们做了什么？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数 new Array</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>()); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>)); <span class="comment">// [undefined x 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array.of()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>)); <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-prototype-keys-、values-、entries"><a href="#Array-prototype-keys-、values-、entries" class="headerlink" title="Array.prototype.keys 、values 、entries"></a>Array.prototype.keys 、values 、entries</h4><p>keys 、values很好理解，分别代表获取数组的索引和对应的值,entries则是输出这两个值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// keys</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 0,1,2,3,4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// values</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> b <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// entries</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// [0, 'a'] [1, 'b']</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Array-prototype-find-和-findIndex"><a href="#Array-prototype-find-和-findIndex" class="headerlink" title="Array.prototype.find 和 findIndex"></a>Array.prototype.find 和 findIndex</h4><p>注意：</p>
<ul>
<li>find方法默认返回第一个符合条件的值,如果没找到则返回undefined,findIndex默认返回第一个符合条件的值的下标,如果没找到返回-1;  </li>
<li>二者接收参数必须得是方法,该回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</li>
<li>这两个方法都可以z找到NaN.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function">(<span class="params">k</span>) =&gt;</span> k &gt; <span class="number">5</span>));  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function">(<span class="params">k</span>) =&gt;</span> k &gt; <span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function">(<span class="params">k</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, k) )); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-prototype-fill-和-copyWithin"><a href="#Array-prototype-fill-和-copyWithin" class="headerlink" title="Array.prototype.fill 和 copyWithin"></a>Array.prototype.fill 和 copyWithin</h4><p>fill可以理解为数组元素替换，可以指定填充开始位置和结束位置，copyWithin则可以理解为用指定元素填充到数组的对应位置，<br>arr.copyWithin(target, start, end) target: 从指定下标开始 index:复制元素的下标 end: 复制元素结束下标<br>来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fill</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="number">4</span>)); <span class="comment">// [4, 4, 4] 不指定开始和结束，全部替换</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="number">4</span>,<span class="number">1</span>)); <span class="comment">// [1, 4, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="number">4</span>,<span class="number">1</span>)); <span class="comment">// [1, 4, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copyWithin</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].copyWithin(<span class="number">1</span>)); <span class="comment">// [1, 1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].copyWithin(<span class="number">2</span>)); <span class="comment">// [1, 2, 1, 2, 3, 4, 5] 未指定复制元素的起始位置，默认用原数组进行填充替换</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>].copyWithin(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 2, 3, 4, 6] 可以理解为从下标为2元素开始，复制下标1-4的数组进行替换填充原数组</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find"></a>Array.prototype.find</h4><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="#解构赋值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">#解构赋值</a></h3><p>使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量;<br>可以很方便得将值和从数组中、属性从对象中提取到不同的变量中：<br>在写React的过程中，也会用到JSX的一个类型写法（Spread Attributes），中文名延展属性，例如子组件需要需要父组件传递a、b、c参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件需要对应的a、b、c三个参数</span></span><br><span class="line">&lt;Component a = &#123;<span class="keyword">this</span>.props.a&#125; b = &#123;<span class="keyword">this</span>.props.b&#125; c = &#123;<span class="keyword">this</span>.props.c&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<p> JSX延展属性写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件需要对应的a、b、c三个参数</span></span><br><span class="line">&lt;Component &#123;...this.props&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<p>数组和对象的解构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的解构赋值</span></span><br><span class="line"></span><br><span class="line">[a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的解构赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;a , b&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果没有实际值，得需要使用‘,’进行占位：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(thirdColor);   <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果你想要获取特定的数组项，并且把剩余的项归在一个数组，那么你可以这样运用 rest操作符 来解构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> color = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'orange'</span>];</span><br><span class="line"><span class="keyword">const</span> [red, ...rest] = color;</span><br><span class="line"><span class="built_in">console</span>.log(red); <span class="comment">// 'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// ['blue', 'orange']</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符和剩余操作符都是以三点省略号开头，二者很像，用法上还是有一定区别:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剩余操作符在函数中的使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, ...args</span>) </span>&#123;  </span><br><span class="line">   <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ); <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符和剩余操作符都是以三点省略号开头，二者很像，用法上还是有一定区别。扩展运算类似于使用‘…’分解数组中的值、对象属性；而剩余操作符是使用‘…’是用来解构和提取数据，多个元素合成一个元素。</p>
<h3 id="let和const"><a href="#let和const" class="headerlink" title="#let和const"></a>#let和const</h3><p>这里将var、let和const进行简单对比：</p>
<ul>
<li>let和const均不能重复声明进行覆盖，而var可以；</li>
<li>let和const存在暂存死区,不存在变量提示,而var存在变量提升；</li>
<li>const一旦声明，不可更改，let和var可以更改；</li>
<li>let定义的变量只存在于块级作用域；</li>
<li>const只定义不赋值，会报错，var、let返回undefined；</li>
<li>let和const 声明的变量不再属于window的属性，可以在下面的例子中体现;</li>
<li>const除了声明的是常量外，其它和let是一样的;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let和const均不能重复声明</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'Hi'</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'Hello'</span>; <span class="comment">// Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const 、let的块级作用域(block-scoping)</span></span><br><span class="line"><span class="keyword">const</span> city = <span class="string">'Beijing'</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> city = <span class="string">'Shanghai'</span>;  </span><br><span class="line">  <span class="built_in">console</span>.log(city); <span class="comment">// Shanghai</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(city); <span class="comment">// Shanghai</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  const 、let的块级作用域(block-scoping),let在for循环里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  const 、let的块级作用域(block-scoping),let在if条件</span></span><br><span class="line"><span class="keyword">if</span>(..) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">'boo'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let和const 声明的变量不再属于window的属性</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>关于<code>暂存死区</code>：在下面的这个例子，在let初始化之前，使用let重复定义在块中的变量，这时会抛错，因为这个变量存在于定义到待初始化处理的一个’暂存死区’中，具体可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">MDN</a>上的解释。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo;</span><br><span class="line">  <span class="keyword">let</span> foo; <span class="comment">// TypeError thrown.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="#箭头函数"></a>#箭头函数</h3><p>在ES6中利用语法糖使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">x</span>) =&gt;</span> x;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有参数，圆括号也可以省略了，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = =&gt; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span> );</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>箭头函数与普通函数的区别：</p>
<ul>
<li>箭头函数的this是它定义时的所在的对象；</li>
<li>没有arguments对象，要访问可以使用剩余操作符代替；</li>
<li>不能使用yield命令，所以箭头函数不能用作Generator函数；</li>
</ul>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="#字符串模板"></a>#字符串模板</h3><p>ES6引入了一种新型的反撇号（`）字符串字面量语法；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用ES6反引号定义</span></span><br><span class="line"><span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;span&gt;keep the <span class="subst">$&#123;things&#125;</span> simple stupid .&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="string">'&lt;div&gt;&lt;span&gt;keep the'</span>+things+<span class="string">' simple stupid .&lt;/span&gt;'</span>+</span><br><span class="line">+<span class="string">'&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="#Promise"></a>#Promise</h3><p>什么是Promise?<br>Promise是抽象异步处理对象以及对其进行各种操作的组件;<br>Promise对象出现避免了使用层层嵌套的回调函数，再也不用担心陷入地狱回调了，Promise的意义就在于 then 链式调用 ，它避免了异步函数之间的层层嵌套，将原来异步函数的嵌套关系 转变为便于阅读和理解的 链式步骤关系，代码也更加直观。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="comment">// a请求</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">      url: <span class="string">'a'</span>,</span><br><span class="line">      dataType:<span class="string">'json'</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 获取data数据 传给下一个b请求</span></span><br><span class="line">          <span class="keyword">var</span> id = data.id;</span><br><span class="line">          $.ajax(&#123;</span><br><span class="line">              url:<span class="string">'b'</span>,</span><br><span class="line">              data:&#123;<span class="string">"id"</span>:id&#125;,</span><br><span class="line">              success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="comment">// 下一个请求 c</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'a'</span>,</span><br><span class="line">        dataType:<span class="string">'json'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;resolve(data)&#125;</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;reject(e)&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line">...b,c...</span><br><span class="line">a.then(b.then())</span><br></pre></td></tr></table></figure>
<p>想要创建一个Promise对象，可以使用new来构造一个新的promise对象,例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 必须给定一个function作为参数，不然会报错；</span></span><br><span class="line"> <span class="comment">// 处理结束后、调用resolve 或 reject</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>大概流程是：</p>
<ol>
<li>new Promise(fn) 返回一个promise对象;</li>
<li>在 fn 中指定异步等处理<br> • 处理结果正常的话，调用 resolve(处理结果值);<br> • 处理结果错误的话，调用 reject(Error对象);</li>
</ol>
<p>Promise对象有以下几个特点：</p>
<ul>
<li>1.有三种状态：<ul>
<li>pending: 初始状态，不是成功或失败状态;</li>
<li>fulfilled: 意味着操作成功完成;</li>
<li>rejected: 意味着操作失败;<br>状态的变化只能是从 Pending 变为 Resolved 和从 Pending 变为 Rejected;</li>
</ul>
</li>
<li>2.Promise的prototype对象上有以下几个方法：<ul>
<li>Promise.then()</li>
<li>Promise.catch()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
<li>Promise.resolve()</li>
<li>Promise.reject()</li>
<li>Promise.done()</li>
<li>Promise.finally()  </li>
</ul>
</li>
</ul>
<p>Promise方法链:<br>其实就是在在Promise里把调用的多个方法连在一起作为一个方法链，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise chain</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"Task A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"Task B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">promise</span><br><span class="line"> .then(taskA)</span><br><span class="line"> .then(taskB)</span><br><span class="line"> .catch(onRejected)</span><br></pre></td></tr></table></figure>
<p>正常流程A task成功-&gt;B task成功-&gt; C task,如果B task失败，将绕过C直接到catch方法，看下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something wrong!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskC</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'catch error: '</span>+ error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line"> .then(taskA)</span><br><span class="line"> .then(taskB)</span><br><span class="line"> .then(taskC)</span><br><span class="line"> .catch(onRejected);</span><br><span class="line"> <span class="comment">// catch error: something wrong! value 是undefined</span></span><br></pre></td></tr></table></figure></p>
<p>关于Promise 链里如何传递参数？</p>
<p>答案很简单，只需要在前一个任务中增加return，下一个任务能接受到这个参数。例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise chain</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskC</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line"> .then(taskA)</span><br><span class="line"> .then(taskB)</span><br><span class="line"> .then(taskC)</span><br><span class="line"> .catch(onRejected);</span><br><span class="line"> <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>之前碰到了一个面试题，都知道promise好用，那Promise有哪些缺点：</p>
<ul>
<li>1.Promise无法终止，一旦建立了就会立即执行；</li>
<li>2.必须严格要求接口规定方法编写代码，例如：不设置回调函数，会抛出错误，不能像回调函数方式那样可以自己自由的定义回调函数参数等；</li>
<li>3.当它处于Pengding状态时候，无法得知目前进行到哪一个阶段了；</li>
</ul>
<p>关于Promise这一节可以参照<a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">promise小人书</a>;</p>
<h3 id="Set和Map"><a href="#Set和Map" class="headerlink" title="#Set和Map"></a>#Set和Map</h3><p>Set和Map是ES6新增的集合类型的数据结构:</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>1.Set可以接受一个数组（或者类数组对象）作为参数，用来初始化;<br>2.Set类似于数组,但是没有重复值;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set本身是一个构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<p>Set内置的方法和属性：</p>
<ul>
<li>add(); // 添加  </li>
<li>clear(); // 清除Set  </li>
<li>delete(); // 删除Set某个值  </li>
<li>has() // 查找某个项  </li>
<li>forEach() // 循环每一项  </li>
<li>keys() // 遍历 key  </li>
<li>values() // 遍历 value  </li>
<li>entries() // 遍历key 和value  </li>
<li>siez 属性，类似于数组的length  </li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map是于对象类似的集合类型数据结构，map与object的不同在与，Object是一种“字符串-值”的对应，Map是“值-值”的对应，map没这个限制。</p>
<p>Map内置的方法和属性：</p>
<ul>
<li>set(); // 添加</li>
<li>clear(); // 清除Set</li>
<li>delete(); // 删除Set某个值</li>
<li>has() // 查找某个项</li>
<li>forEach() // 循环每一项</li>
<li>keys() // 遍历 key</li>
<li>values() // 遍历 value</li>
<li>entries() // 遍历key 和value</li>
<li>siez 属性，类似于数组的length</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="#Symbol"></a>#Symbol</h3><p>Symbol既不是值也不是对象，它是第七种原始类型，是可以用来作为对象属性键的值。<br>Symbol的目的就是为了实现一个唯一不重复不可变的值；有两种方法来生产一个Symbol类型的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Symbol函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>()); <span class="comment">// Symbol()</span></span><br><span class="line"><span class="comment">// Symbol.for方法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>.for(<span class="string">'symbA'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">'symbA'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.for(<span class="string">'symbA'</span>)); <span class="comment">// Symbol(symbA)</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Symbol(a)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)) <span class="comment">// 'symbol' </span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Symbol(a)</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Symbol可以用作对象属性名，但是区别是无法通过.来定义该属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> symbola = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b.symbola = <span class="string">'this is not a symbola!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//&#123; 'symbola' : 'this is not a symbola!'&#125;</span></span><br><span class="line">b = &#123;<span class="attr">symbola</span>:<span class="string">'this is a symbola!'</span>&#125;;  <span class="comment">// &#123; Symbol() : 'this is a symbola!'&#125;</span></span><br></pre></td></tr></table></figure>
<p>Symbol无法在for…in、for…of被遍历查找到，看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;<span class="string">'a'</span>: <span class="string">'a'</span>,<span class="string">'a'</span>:<span class="string">'b'</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a )&#123;<span class="built_in">console</span>.log(i)&#125; <span class="comment">// a, b</span></span><br><span class="line">a[<span class="built_in">Symbol</span>(<span class="string">'c'</span>)] = <span class="string">'c'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123; a: "a", b: "b", Symbol(c): "c" &#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a )&#123;<span class="built_in">console</span>.log(i)&#125; <span class="comment">// a, b</span></span><br></pre></td></tr></table></figure>
<p>Symbol类型的一些应用途径：</p>
<ul>
<li>1.由于它的唯一性，每一个Symbol值都不相等，这意味着Symbol值可以作为标识符用于对象的属性名，不会出现同名的属性。(如果你定义同名属性对象，其实是被覆盖的，得的是后定义的属性值)</li>
<li>2.Symbol类型的属性名无法被for…in等方法遍历到，可以用于定义一些私有属性。</li>
</ul>
<h3 id="模块module"><a href="#模块module" class="headerlink" title="#模块module"></a>#模块module</h3><p> 可以把模块理解为是一个独立的Javascript文件，在ES的module出现之前，JavaScript一直没有模块系统，先回顾一下前端的模块系统，了解一下什么是模块化？CommonJS又是什么？AMD和CMD规范分别有什么特点？</p>
<h4 id="关于CommonJS"><a href="#关于CommonJS" class="headerlink" title="关于CommonJS"></a>关于CommonJS</h4><p>CommonJs最先源于nodejs社区，关于CommonJS的规范可以查看<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="noopener">这里</a>，先看下它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>, i = <span class="number">0</span>, args = <span class="built_in">arguments</span>, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">        sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// increment.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">'increment'</span>).increment;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">inc(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>CommonJs原先叫ServerJS,仅看名字就知道这个库服务于后端，也就是说在Nodejs等环境下用是没有问题的，但不适用于浏览器端，到了浏览器中，这样引用会出现问题：</p>
<ul>
<li>浏览器环境并不提供module、require等外部直接引用变量。</li>
<li>nodejs环境中require一个模块是直接从硬盘或内存中读取该文件，但到了浏览器中你需要从服务器中去下载这个文件，这就得发送http请求，require资源需要请求完才能执行。  </li>
</ul>
<p>社区在解决这个问题的时候产生了分歧：</p>
<ul>
<li>Modules/1.x 流派：<br>  1.x规范已经够用了，只需移植到浏览器端即可。例如工具Browserify就能将你的CommonJS代码转换成浏览器端也能执行的代码；</li>
<li>Modules/Async 流派<br>  这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。</li>
</ul>
<h4 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h4><p>AMD(异步模块定义)规范既然在浏览器端不支持，那么就改进CommonJS规范，先定义好你需要引用的模块，进行异步加载，在回调函数里执行逻辑代码，制定了一个Modules/Wrappings规范，具体二者有什么区别点击<a href="https://www.zhihu.com/question/20351507" target="_blank" rel="noopener">这里</a><br>AMD标准是requireJs定义的标准，而CMD是seaJS定义的标准，这两者有什么区别：</p>
<ul>
<li>对于依赖的模块，AMD是提前执行，CMD是延迟执行；</li>
<li>CMD依赖就近，也就是说需要用到时才写,AMD依赖前置，一开始就得把所需依赖写好；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">"require"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里，模块 a 已经下载并执行好</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>关于二者的区别可以查看知乎回答<a href="https://www.zhihu.com/question/20351507" target="_blank" rel="noopener">AMD 和 CMD 的区别有哪些？</a></p>
<h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>modules规范分两部分，一部分是如何导出export，一部分是如何导入import。<br>任何的值(例如方法、变量)都可以作为一个modules被导出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件 a.js 直接导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> value = <span class="string">'module'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">helloworld</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world~'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先定义再导出也是正确的</span></span><br><span class="line"><span class="keyword">export</span> &#123;PI, value&#125;;</span><br><span class="line"><span class="comment">// 你也可以使用as进行重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;name1 <span class="keyword">as</span> PI, name2 <span class="keyword">as</span> value&#125;;</span><br></pre></td></tr></table></figure>
<p>使用export命令导出模块后，那么可以在其他文件中通过import命令来导入这个模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按需导入</span></span><br><span class="line"><span class="keyword">import</span> &#123;PI, helloworld&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"><span class="comment">// 对变量进行重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123;PI <span class="keyword">as</span> p&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br></pre></td></tr></table></figure>
<p>default默认导出,export default是输出一个叫做default的变量或方法；它的后面不能再跟变量声明语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js 模块默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者这样写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloworld</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> helloworld;</span><br><span class="line"><span class="comment">// 这样写会导致错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> helloworld = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引入的时候,不可以使用 类似&#123;helloworld&#125;这样的写法</span></span><br><span class="line"><span class="keyword">import</span> helloworld <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line">helloword(); <span class="comment">// 'hello world'</span></span><br></pre></td></tr></table></figure>
<p>关于default：</p>
<ul>
<li>export default是输出一个叫做default的变量或方法；它的后面不能再跟变量声明语句；</li>
<li>export default导出的模块，不能使用大括号方式导入；</li>
<li>一个文件内不能使用多个export default；</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="#Class类"></a>#Class类</h3><h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>class是创建类对象与实现类继承的语法糖，旨在让ES5中对象原型的写法更加清晰，易读。<br>在ES6前，如果想实现class面向对象的例子，我们通常使用function来模拟：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.toSayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Hello, my name is'</span> + <span class="keyword">this</span>.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> People(<span class="string">'ES6'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  toSayHello() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Hello, my name is'</span> + <span class="keyword">this</span>.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的缺点：每次实例化一个对象，就会执行构造函数里的代码，因此每当这个类被实例化的时候，这些方法和属性就会被拷贝到实例化出来的对象中,这样就会重复地在内存中分配一定区域来存储这些变量和方法。为了解决这个方法，可以在prototype中来添加该类的一系列常量和方法。定义在prototype的中的方法和属性，新实例出来的对象会进行引用，不会产生“吃内存”的现象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People.prototype.toSayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Hello, my name is'</span> + <span class="keyword">this</span>.name )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> People(<span class="string">'ES6'</span>);</span><br></pre></td></tr></table></figure>
<p>function声明存在变量提升，但class的定义不存在提升；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(helloWorld());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>() </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4><p>constructor属性返回对创建此对象的构造函数的引用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a.constructor <span class="comment">// function Array()&#123;...&#125;</span></span><br><span class="line">a.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="static-静态"><a href="#static-静态" class="headerlink" title="static 静态"></a>static 静态</h4><p>类相当于实例的原型，所有在类里定义的方法，实例都能继承。但是在方法面前加上static关键字，就表示该方法不会被实例继承，该方法也被称作“静态方法”。<br>目前ES6只有静态方法，并没有静态属性，在ES7中有关于静态属性的提案，静态属性或方法需要用类名进行调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//es7对于实例属性的提案，此属性可以在实例中访问到</span></span><br><span class="line">  type = <span class="string">'animal'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//es7对于类的静态属性的提案，同样Babel支持</span></span><br><span class="line">  <span class="keyword">static</span> myType = <span class="string">'static'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  toSayHello() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Hello, my name is'</span> + <span class="keyword">this</span>.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ES5的继承"><a href="#ES5的继承" class="headerlink" title="ES5的继承"></a>ES5的继承</h4><p>通过原型链实现继承：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span> + food + <span class="string">'~~'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将父类的实例作为子类的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">'cat'</span>;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep()); <span class="comment">// cat 正在睡觉</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="a-原型链继承"><a href="#a-原型链继承" class="headerlink" title="a.原型链继承"></a>a.原型链继承</h5><h4 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h4><p>可以通过extends关键字继承父类的所有属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  toSayHello() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Hello, my name is'</span> + <span class="keyword">this</span>.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用extends Woman 继承了People的所有属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象;</p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="# Generator"></a># Generator</h3><h4 id="Generator的定义"><a href="#Generator的定义" class="headerlink" title="Generator的定义"></a>Generator的定义</h4><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。Generator函数的调用方法与普通函数不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，我们可以通过调用 next 方法，使得指针移向下一个状态。如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">stepGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'step1'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'step2'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'it is a generator'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = stepGenerator();</span><br><span class="line">g1; <span class="comment">// stepGenerator.....</span></span><br><span class="line">g1.next(); <span class="comment">// Object &#123;value: "step1", done: false&#125;</span></span><br><span class="line">g1.next(); <span class="comment">// Object &#123;value: "step2", done: false&#125;</span></span><br><span class="line">g1.next(); <span class="comment">// Object &#123;value: "it is a generator", done: true&#125;</span></span><br><span class="line">g1.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实际上function<em> stepGenerator 和 function </em> stepGenerator 或者 function *stepGenerator得到的结果是一样的，只是写法不一样；</li>
</ul>
<p>调用stepGenerator对象的时候，Generator并没有被立即执行，调用next方法时，函数开始执行，next 方法返回一个拥有 value 和 done 两个字段的对象,下次调用 next，函数会从 yield 的下一个语句继续执行,等到整个函数执行完，next 方法返回的 done 字段会变成true。</p>
<p>不仅仅yield语句会中断执行，如果Generator中在yield前有return，同样也会停止执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">stepGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'it is a generator'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'step1'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'step2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = stepGenerator();</span><br><span class="line">g1; <span class="comment">// stepGenerator.....</span></span><br><span class="line">g1.next();  <span class="comment">// Object &#123;value: "it is a generator", done: true&#125;</span></span><br><span class="line">g1.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Generator的输入输出"><a href="#Generator的输入输出" class="headerlink" title="Generator的输入输出"></a>Generator的输入输出</h4><p>总结一下Generator与常见的函数有一些共同点，但也有一些差异：</p>
<ul>
<li>通常函数以Function开始，Generator以Function*开始；</li>
<li>常见的函数一旦执行不能暂停，但是Generator可以，并且通过yield关键字来暂停执行；</li>
<li>generator内部多了yield关键字，yield类似于普通函数的return，但是不同的是可以有多个yield暂停Generator函数的执行；</li>
<li>常见的函数执行之后会返回结果，Generator执行之后返回Generator对象;</li>
</ul>
<p>更多关于Generator:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noopener">迭代器和生成器</a><br><a href="http://wingolog.org/archives/2013/05/08/generators-in-v8" target="_blank" rel="noopener">generators in v8</a><br><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-generators/" target="_blank" rel="noopener">ES6 In Depth: Generators</a><br>（…）</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写, Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>Proxy 已经被几乎所有的现代化浏览器兼容。（当然IE不是一个现代化浏览器）,Proxy 接收两个对象参数，一个是需要代理的 object 对象，另一个handler也是一个对象，在这个对象里定义对所代理的对象进行设置的方法。<br>例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">	gets (obj, prop) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(obj)</span><br><span class="line">	<span class="built_in">console</span>.log(prop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line"><span class="built_in">console</span>.log(proxy) <span class="comment">// Proxy &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.a) <span class="comment">// &#123;a: 1, b: 2&#125; a</span></span><br></pre></td></tr></table></figure></p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ECMAScript 6 入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">MDN</a></li>
<li><a href="http://es6-features.org/#BlockScopedVariables" target="_blank" rel="noopener">ECMAScript 6 — New Features</a> </li>
<li><a href="https://github.com/lukehoban/es6features" target="_blank" rel="noopener">ECMAScript6 features Github</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      wuxinhua
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://wuxinhua.com/2017/08/28/The-es6-features-learning-notes/" title="ES6(ECMAScript 6.0)新特征">https://wuxinhua.com/2017/08/28/The-es6-features-learning-notes/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/30/React-redux-connect-Explain-in-detail/" rel="next" title="对React-redux中connect方法的理解">
                <i class="fa fa-chevron-left"></i> 对React-redux中connect方法的理解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/13/What-happen-from-input-the-URL-in-the-browser-to-the-page-bring-out/" rel="prev" title="从面试题“输入URL...发生了什么?”学到的(上)">
                从面试题“输入URL...发生了什么?”学到的(上) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="wuxinhua">
          <p class="site-author-name" itemprop="name">wuxinhua</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">#目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组方法扩展"><span class="nav-number">2.</span> <span class="nav-text">#数组方法扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-includes"><span class="nav-number">2.1.</span> <span class="nav-text">Array.prototype.includes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-from"><span class="nav-number">2.2.</span> <span class="nav-text">Array.prototype.from</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-of"><span class="nav-number">2.3.</span> <span class="nav-text">Array.prototype.of</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-keys-、values-、entries"><span class="nav-number">2.4.</span> <span class="nav-text">Array.prototype.keys 、values 、entries</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-find-和-findIndex"><span class="nav-number">2.5.</span> <span class="nav-text">Array.prototype.find 和 findIndex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-fill-和-copyWithin"><span class="nav-number">2.6.</span> <span class="nav-text">Array.prototype.fill 和 copyWithin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-find"><span class="nav-number">2.7.</span> <span class="nav-text">Array.prototype.find</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解构赋值"><span class="nav-number">3.</span> <span class="nav-text">#解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let和const"><span class="nav-number">4.</span> <span class="nav-text">#let和const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#箭头函数"><span class="nav-number">5.</span> <span class="nav-text">#箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串模板"><span class="nav-number">6.</span> <span class="nav-text">#字符串模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">7.</span> <span class="nav-text">#Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set和Map"><span class="nav-number">8.</span> <span class="nav-text">#Set和Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">8.1.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">8.2.</span> <span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol"><span class="nav-number">9.</span> <span class="nav-text">#Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块module"><span class="nav-number">10.</span> <span class="nav-text">#模块module</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于CommonJS"><span class="nav-number">10.1.</span> <span class="nav-text">关于CommonJS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AMD和CMD"><span class="nav-number">10.2.</span> <span class="nav-text">AMD和CMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Module"><span class="nav-number">10.3.</span> <span class="nav-text">Module</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class类"><span class="nav-number">11.</span> <span class="nav-text">#Class类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的声明"><span class="nav-number">11.1.</span> <span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor-方法"><span class="nav-number">11.2.</span> <span class="nav-text">constructor 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-静态"><span class="nav-number">11.3.</span> <span class="nav-text">static 静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES5的继承"><span class="nav-number">11.4.</span> <span class="nav-text">ES5的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-原型链继承"><span class="nav-number">11.4.1.</span> <span class="nav-text">a.原型链继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6的继承"><span class="nav-number">11.5.</span> <span class="nav-text">ES6的继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator"><span class="nav-number">12.</span> <span class="nav-text"># Generator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator的定义"><span class="nav-number">12.1.</span> <span class="nav-text">Generator的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator的输入输出"><span class="nav-number">12.2.</span> <span class="nav-text">Generator的输入输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy"><span class="nav-number">12.3.</span> <span class="nav-text">Proxy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附录"><span class="nav-number">13.</span> <span class="nav-text">附录</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="author" itemprop="copyrightHolder">Created with </span>
  <span class="with-love">
    <i class="fa fa-heart"></i> 
  </span> by <a class="theme-link" href="https://github.com/M1seRy">
     wuxinhua
   </a>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

 <div class="theme-info">
  Host by
    <a class="theme-link" href="https://www.aliyun.com/">
    Aliyun 
   </a>
 </div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

  <div class="galleria"></div>
<script type="text/javascript">
    console.log('人生如逆旅，我亦是行人。')
</script>
  
</body>
</html>
